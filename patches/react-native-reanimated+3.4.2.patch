diff --git a/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/NodesManager.java b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/NodesManager.java
index 59ba0b6..e6b8794 100644
--- a/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/NodesManager.java
+++ b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/NodesManager.java
@@ -203,7 +203,9 @@ public class NodesManager implements EventDispatcherListener {
 
   public void performOperations() {
     if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
-      mNativeProxy.performOperations();
+      if (mNativeProxy != null) {
+        mNativeProxy.performOperations();
+      }
     } else if (!mOperationsInBatch.isEmpty()) {
       final Queue<NativeUpdateOperation> copiedOperationsQueue = mOperationsInBatch;
       mOperationsInBatch = new LinkedList<>();
@@ -302,18 +304,20 @@ public class NodesManager implements EventDispatcherListener {
 
   @Override
   public void onEventDispatch(Event event) {
+    if (mNativeProxy == null) {
+      return;
+    }
     // Events can be dispatched from any thread so we have to make sure handleEvent is run from the
     // UI thread.
     if (UiThreadUtil.isOnUiThread()) {
       handleEvent(event);
       performOperations();
     } else {
-      boolean shouldSaveEvent = false;
       String eventName = mCustomEventNamesResolver.resolveCustomEventName(event.getEventName());
       int viewTag = event.getViewTag();
       String key = viewTag + eventName;
 
-      shouldSaveEvent |= mNativeProxy != null && mNativeProxy.isAnyHandlerWaitingForEvent(key);
+      boolean shouldSaveEvent = mNativeProxy.isAnyHandlerWaitingForEvent(key);
       if (shouldSaveEvent) {
         mEventQueue.offer(new CopiedEvent(event));
       }
